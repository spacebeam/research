<!DOCTYPE html>
<html lang="en">
<head>
          <title>Spacebeam: Distributed Artificial Intelligence</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta charset="utf-8" />
        <link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Spacebeam: Distributed Artificial Intelligence Full Atom Feed" />
        <link href="/feeds/updates.atom.xml" type="application/atom+xml" rel="alternate" title="Spacebeam: Distributed Artificial Intelligence Categories Atom Feed" />
        <!-- twitter card metadata -->
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="/images/logo.png">
<meta name="twitter:site" content="@SpacebeamOrg">
<meta name="twitter:title" content="8 Supply, 11 Gas, 12 Rax, 14 Scout">
<meta name="twitter:description" content="Let's train some workers when we have the minerals for them!">
        <!-- OG Tags -->
<meta property="og:url" content="/2020/07/11/8-supply-11-gas-12-rax-14-scout/"/>
<meta property="og:title" content="Spacebeam: Distributed Artificial Intelligence | 8 Supply, 11 Gas, 12 Rax, 14 Scout" />
<meta property="og:description" content="Let's train some workers when we have the minerals for them!" />
        <!-- favicon -->
        <link rel="icon" type="image/png" href="/images/logo.png">
        <!-- moment.js for date formatting -->
        <script src="/theme/js/moment.js"></script>
        <!-- css -->
        <link rel="stylesheet" type="text/css" href="/theme/css/main.css" />
		<script>
			
                /*! grunt-grunticon Stylesheet Loader - v2.1.2 | https://github.com/filamentgroup/grunticon | (c) 2015 Scott Jehl, Filament Group, Inc. | MIT license. */
    
    (function(e){function t(t,n,r,o){"use strict";function a(){for(var e,n=0;u.length>n;n++)u[n].href&&u[n].href.indexOf(t)>-1&&(e=!0);e?i.media=r||"all":setTimeout(a)}var i=e.document.createElement("link"),l=n||e.document.getElementsByTagName("script")[0],u=e.document.styleSheets;return i.rel="stylesheet",i.href=t,i.media="only x",i.onload=o||null,l.parentNode.insertBefore(i,l),a(),i}var n=function(r,o){"use strict";if(r&&3===r.length){var a=e.navigator,i=e.Image,l=!(!document.createElementNS||!document.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect||!document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image","1.1")||e.opera&&-1===a.userAgent.indexOf("Chrome")||-1!==a.userAgent.indexOf("Series40")),u=new i;u.onerror=function(){n.method="png",n.href=r[2],t(r[2])},u.onload=function(){var e=1===u.width&&1===u.height,a=r[e&&l?0:e?1:2];n.method=e&&l?"svg":e?"datapng":"png",n.href=a,t(a,null,null,o)},u.src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==",document.documentElement.className+=" grunticon"}};n.loadCSS=t,e.grunticon=n})(this);(function(e,t){"use strict";var n=t.document,r="grunticon:",o=function(e){if(n.attachEvent?"complete"===n.readyState:"loading"!==n.readyState)e();else{var t=!1;n.addEventListener("readystatechange",function(){t||(t=!0,e())},!1)}},a=function(e){return t.document.querySelector('link[href$="'+e+'"]')},c=function(e){var t,n,o,a,c,i,u={};if(t=e.sheet,!t)return u;n=t.cssRules?t.cssRules:t.rules;for(var l=0;n.length>l;l++)o=n[l].cssText,a=r+n[l].selectorText,c=o.split(");")[0].match(/US\-ASCII\,([^"']+)/),c&&c[1]&&(i=decodeURIComponent(c[1]),u[a]=i);return u},i=function(e){var t,o,a;o="data-grunticon-embed";for(var c in e)if(a=c.slice(r.length),t=n.querySelectorAll(a+"["+o+"]"),t.length)for(var i=0;t.length>i;i++)t[i].innerHTML=e[c],t[i].style.backgroundImage="none",t[i].removeAttribute(o);return t},u=function(t){"svg"===e.method&&o(function(){i(c(a(e.href))),"function"==typeof t&&t()})};e.embedIcons=i,e.getCSS=a,e.getIcons=c,e.ready=o,e.svgLoadedCallback=u,e.embedSVG=u})(grunticon,this);
                
                grunticon(["/theme/css/icons.data.svg.css", "/theme/css/icons.data.png.css", "/theme/css/icons.fallback.css"]);
            </script>
        <noscript><link href="/theme/css/icons.fallback.css" rel="stylesheet"></noscript>
        <!-- menu toggle javascript -->
        <script type="text/javascript">
            document.addEventListener("DOMContentLoaded", initMenu);
            
            function initMenu(){
                var menu = document.getElementById("menu");
                var menulink = document.getElementById("menu-link");
                menulink.addEventListener("click", function toggleMenu(){
                        window.event.preventDefault();
                        menulink.classList.toggle('active');
                        menu.classList.toggle('active');              
                    });
            };
        </script>

    <meta name="description" content="Let's train some workers when we have the minerals for them!" />


</head>
<body>
    <div role="banner" id="masthead">
        <header>
            <a href="/"><img src="/images/logo.png" alt="McManus Logo"></a>
            <a href="#menu" id="menu-link">more stuff</a>
            <nav id="menu">
                <ul>
                        <li><a href="/pages/about/">about</a></li>
                        <li><a href="/pages/research/">research</a></li>
                        <li><a href="/pages/technology/">technology</a></li>
                            <li class="active"><a href="/category/updates">updates</a></li>
                </ul>
            </nav>
        </header>
    </div>
        <div class="page" role="main">
  <div class="article" role="article">
    <article>
        <footer>
            <a name="top"></a>
            <p>
              <time datetime=" 2020-07-11 00:00:00+02:00">
                <script>document.write(moment('2020-07-11 00:00:00+02:00').format('LL'));</script>
              </time>
            </p>
        </footer>
        <header>
          <h2>
            8 Supply, 11 Gas, 12 Rax, 14 Scout
          </h2>
        </header>
      <div class="content">
         <p>That's the basics you go out, 16 supply, 16 factory, train 2 marines and put them with 1 scv at front on the ramp, 22 cc, 24 supply, 25 tank, 26 ebay.</p>
<p>This tutorial will walk you through StarCraft: Brood War bot development with Python, but first we are going to dive deep into <a href="https://en.wikipedia.org/wiki/Coroutine">Coroutines</a>!</p>
<p>Real-time strategy (RTS) games are known to be one of the most complex game genres for humans and machines to play. To tackle the task we focus on a message-passing divide-and-conquer approach with <a href="https://zeromq.org">ZMQ</a> and multiple languages, splitting the game into separate components and developing separate systems to solve each task.</p>
<p>This trend gives rise to a new problem: how to tie these systems together into a functional StarCraft: Brood War playing bot?</p>
<h2>Coroutines</h2>
<p><em>Coroutines</em> are computer-program components that generalize subroutines for non-preemptive multitasking by allowing multiple entry points for suspending and resuming execution at certain locations.</p>
<p>Subroutines are short programs that perform functions of a general nature that can occuir in varios types of computation.</p>
<p>A sequence of program instructions that perform a specific task, packaged as a unit. This unit can then be used in programs wherever that particular task should be performed.</p>
<p>Subprograms may be defined within programs, or separately in libraries that can be used by multiple programs.</p>
<p>In different programming languages, a subroutine may be called a procedure, a function a routine, a method, a subprogram.</p>
<h3>Difference with processes</h3>
<p>Processes are idependent units of execution, a subroutine lives inside a process.</p>
<h3>Cooperative multitasking</h3>
<p>Also known as non-preemptive multitasking, is a style of computer multitasking in which the operating system never initiates a context switch from a running process to another process.</p>
<p>Instead, processes voluntary yield control periodically or when idle in order to enable multiple applications to be run concurrently.</p>
<h2>Python 3 <code>await</code> and <code>yield</code></h2>
<p>Python uses a single-threaded event loop to enable concurrent actions. This means that all real-time aplication code should aim to be asynchronous and non-blocking because only one operation can be active at a time.</p>
<p>Asynchronous operations generally return placeholder objects (<a href="https://docs.python.org/3.7/library/concurrent.futures.html">Futures</a>).
<code>Futures</code> are usually transformed into their result with the <code>await</code> and <code>yield</code>.</p>
<h3>Examples</h3>
<p>Here is a sample synchronous function:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">tornado.httpclient</span> <span class="kn">import</span> <span class="n">HTTPClient</span>

<span class="k">def</span> <span class="nf">synchronous_fetch</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">http_client</span> <span class="o">=</span> <span class="n">HTTPClient</span><span class="p">()</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">http_client</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span><span class="o">.</span><span class="n">body</span>
</pre></div>


<p>And here the same rewritten asynchronously as a native coroutine:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">tornado.httpclient</span> <span class="kn">import</span> <span class="n">AsyncHTTPClient</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">asynchronous_fetch</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">http_client</span> <span class="o">=</span> <span class="n">AsyncHTTPClient</span><span class="p">()</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">await</span> <span class="n">http_client</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span><span class="o">.</span><span class="n">body</span>
</pre></div>


<p>Anything you can do with coroutines you can also do by passing callback around, but coroutines
provide an important simplification by letting you organize your code in the same way you would if it
were synchronous, important for error handling since <code>try/expect</code> work as you would expect.</p>
<h2>Why ZeroMQ helps?</h2>
<p>ZeroMQ is a community of projects focused on decentralized message passing. They agree on protocols (RFCs) for connecting to each other and exchanging messages. Messages are blobs of useful data of any reasonable size.</p>
<p>You can use this feature to queue, route, and filter messages according to various <code>patterns</code>.</p>
<p>Multilingual Distributed Messaging thanks to the ZeroMQ Community.</p>
<ul>
<li>Carries messages across inproc, IPC, TCP, multicast.</li>
<li>Smart patterns like pub-sub, push-pull, request-reply.</li>
<li>Backed by a large and active open-source community.</li>
</ul>
<p>It's asynchronous I/O model gives you scalable multicore applications, built as asynchronous message-processing subroutines. <a href="http://zguide.zeromq.org/">Read the guide</a>.</p>
<h2>Coroutines again</h2>
<p>Coroutines are the recommended way to write asynchronous code.</p>
<p><em>Coroutines</em> use the Python 3 <code>await</code> or <code>yield</code> keyword to suspend and resume execution instead of a chain of callbacks, all coroutines use explicit context switches and are called as asynchronous functions.</p>
<p>Coroutines are almost as simple as synchronous code, but without the expense of a thread. They make concurrency easier to reason about by reducing the number of places where a context switch can happen.</p>
<h3>How to call a coroutine</h3>
<p>Coroutines do not raise exceptions in the normal way: any exception they raise will be trapped in the awaitable object until it is yielded.
This means it is important to call coroutines in the right way, or you may have errors that do unnoticed:</p>
<div class="highlight"><pre><span></span><span class="n">async</span> <span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">bad_call</span><span class="p">()</span>
    <span class="c1"># This should raise ZeroDivisionError, but it won&#39;t</span>
    <span class="c1"># because the coroutine is called incorrectly!</span>
    <span class="n">divide</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>


<p>In nearly all cases, any function that calls a coroutine must be a coroutine itself, 
and use the <code>await</code> or <code>yield</code> keyword in the call.</p>
<div class="highlight"><pre><span></span><span class="n">async</span> <span class="k">def</span> <span class="nf">good_call</span><span class="p">():</span>
    <span class="c1"># await will unwrap the object returned by divide()</span>
    <span class="c1"># and raise the expection.</span>
    <span class="n">await</span> <span class="n">divide</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>


<h4>Fire and forget</h4>
<p>Sometimes you may want to "fire and forget" a coroutine without waiting for its result. In this case it is recommended to use <code>IOLoop.spawn_callback</code>, which makes the <code>IOLoop</code> responsible for the call.
If it fails, the <code>IOLoop</code> will log a stack trace:</p>
<div class="highlight"><pre><span></span><span class="c1"># The IOLoop will catch the expection and print a stack trace</span>
<span class="c1"># in the logs. Note that this doesn&#39;t look like a normal call,</span>
<span class="c1"># since we pass the function object to be called by the IOLoop.</span>
<span class="n">IOLoop</span><span class="o">.</span><span class="n">current</span><span class="p">()</span><span class="o">.</span><span class="n">spawn_callback</span><span class="p">(</span><span class="n">divide</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>


<h2>Coroutine patterns</h2>
<h3>Calling blocking functions</h3>
<p>The simplest way to call a blocking function from a coroutine is to use <code>IOLoop.run_in_executor</code>, which returns <code>Futures</code> that are compatible:</p>
<div class="highlight"><pre><span></span><span class="n">async</span> <span class="k">def</span> <span class="nf">call_blocking</span><span class="p">():</span>
    <span class="n">await</span> <span class="n">IOLoop</span><span class="o">.</span><span class="n">current</span><span class="p">()</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">blocking_func</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
</pre></div>


<h3>Parallelism</h3>
<p>The <code>multi</code> function accepts lists and dicts whose values are <code>Futures</code> and waits for all of those <code>Futures</code> in parallel:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">tornado.gen</span> <span class="kn">import</span> <span class="n">multi</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">parallel_fetch</span><span class="p">(</span><span class="n">url1</span><span class="p">,</span> <span class="n">url2</span><span class="p">):</span>
    <span class="n">resp1</span><span class="p">,</span> <span class="n">resp2</span> <span class="o">=</span> <span class="n">await</span> <span class="n">multi</span><span class="p">([</span><span class="n">http_client</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">url1</span><span class="p">),</span>
                                <span class="n">http_client</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">url2</span><span class="p">)]</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">parallel_fetch_many</span><span class="p">(</span><span class="n">urls</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">await</span> <span class="n">multi</span><span class="p">([</span><span class="n">http_client</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">])</span>
    <span class="c1"># res is a list of HTTPResponses in the same order</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">parallel_fetch_dict</span><span class="p">(</span><span class="n">urls</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">await</span> <span class="n">multi</span><span class="p">({</span><span class="n">url</span><span class="p">:</span> <span class="n">http_client</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">})</span>
    <span class="c1"># res is a dict {url: HTTPResponse}</span>
</pre></div>


<p>In decorated coroutines, it is possible to <code>yield</code> the list or dict directly:</p>
<div class="highlight"><pre><span></span><span class="nd">@gen.coroutine</span>
<span class="k">def</span> <span class="nf">parallel_fetch_decorated</span><span class="p">(</span><span class="n">url1</span><span class="p">,</span> <span class="n">url2</span><span class="p">):</span>
    <span class="n">resp1</span><span class="p">,</span> <span class="n">resp2</span> <span class="o">=</span> <span class="k">yield</span> <span class="p">[</span><span class="n">http_client</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">url1</span><span class="p">),</span>
                          <span class="n">http_client</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">url2</span><span class="p">)]</span>
</pre></div>


<h3>Interleaving</h3>
<p>Sometimes it is useful to save a <code>Future</code> instead of yielding it immediately, so you can start another operation before waiting.</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">tornado.gen</span> <span class="kn">import</span> <span class="n">convert_yielded</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># convert_yielded() starts the native coroutine in the background.</span>
    <span class="c1"># This is equivalent to asyncio.ensure_future() (both work)</span>
    <span class="n">fetch_future</span> <span class="o">=</span> <span class="n">convert_yielded</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fetch_next_chunk</span><span class="p">())</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">fetch_future</span>
        <span class="k">if</span> <span class="n">chunk</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">break</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="n">fetch_future</span> <span class="o">=</span> <span class="n">convert_yielded</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fetch_next_chunk</span><span class="p">())</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
</pre></div>


<p>This is a little easier to do with decorated coroutines, because they start immediately when called:</p>
<div class="highlight"><pre><span></span><span class="nd">@gen.coroutine</span>
<span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">fetch_future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch_next_chunk</span><span class="p">()</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">fetch_future</span>
        <span class="ow">is</span> <span class="n">chunk</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">break</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="n">fetch_future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch_next_chunk</span><span class="p">()</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
</pre></div>


<h3>Looping</h3>
<p>In native coroutines, <code>async for</code> can be used.</p>
<h3>Running in the background</h3>
<p><code>PeriodicCallback</code> is not normally used with coroutines. Instead, a coroutine can contain a <code>while True:</code> loop and use <code>tornado.gen.sleep</code>:</p>
<div class="highlight"><pre><span></span><span class="n">async</span> <span class="k">def</span> <span class="nf">minute_loop</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">await</span> <span class="n">do_something</span><span class="p">()</span>
        <span class="n">await</span> <span class="n">gen</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>

<span class="c1"># Coroutines that loop forever are generally started with</span>
<span class="c1"># spawn_callback().</span>
<span class="n">IOLoop</span><span class="o">.</span><span class="n">current</span><span class="p">()</span><span class="o">.</span><span class="n">spawn_callback</span><span class="p">(</span><span class="n">minute_loop</span><span class="p">)</span>
</pre></div>


<p>Sometimes a more complicated loop may be desirable. For example, the previous loop runs every <code>60+N</code> seconds,
where <code>N</code> is the running time of <code>do_something()</code>. To run exactly every 60 seconds, use the interleaving pattern from above:</p>
<div class="highlight"><pre><span></span><span class="n">async</span> <span class="k">def</span> <span class="nf">minute_loop2</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">nxt</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>  <span class="c1"># Start the clock.</span>
        <span class="n">await</span> <span class="n">do_something</span><span class="p">()</span> <span class="c1"># Run while the clock is ticking.</span>
        <span class="n">await</span> <span class="n">nxt</span>            <span class="c1"># Wait fot he timer to run out.</span>
</pre></div>
      </div>
      <div class="back-to-top">
          <a href="#top">back to top</a>
      </div>
      <div id="disqus_thread"></div>
        <script>
        (function() {
              var d = document, s = d.createElement('script');
              s.src = 'https://spacebeam.disqus.com/embed.js';
              s.setAttribute('data-timestamp', +new Date());
              (d.head || d.body).appendChild(s);
        })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </article>
  </div>
<!-- end article -->
                <footer>
                    <div class="icons">
                        <a href="https://twitter.com/SpacebeamOrg" target="_blank"><div class="icon-twitter icon"></div></a>
                        <a href="https://github.com/spacebeam" target="_blank"><div class="icon-github icon"></div></a>
                    </div>
                    <p>Â© <script>document.write(moment().format('YYYY'));</script> Spacebeam Community</p>
                </footer>
        </div>
</body>
</html>